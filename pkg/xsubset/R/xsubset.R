## new generics
xsubset <- function(object, ...) UseMethod("xsubset")

refit <- function(object, ...) UseMethod("refit")


## xsubset methods
## standard formula interface
xsubset.formula <- function(formula, data, subset, na.action, weights, offset, ...,
  model = TRUE, y = TRUE, x = FALSE)
{
  ## keep call (of generic)
  call <- match.call()
  call[[1]] <- as.name("xsubset")

  ## call model.frame
  mf <- match.call(expand.dots = FALSE)
  m <- match(c("formula", "data", "subset", "na.action", "weights", "offset"), names(mf), 0)
  mf <- mf[c(1, m)]
  mf$drop.unused.levels <- TRUE
  mf[[1]] <- as.name("model.frame")
  mf <- eval(mf, parent.frame())

  ## extract X and Y
  mt <- terms(formula, data = data)
  X <- model.matrix(mt, mf)
  Y <- model.extract(mf, "response")

  ## weights and offset
  weights <- model.weights(mf)
  if(is.null(weights)) weights <- rep(1, NROW(X))
  weights <- structure(as.vector(weights), .Names = rownames(mf))
  offset <- model.offset(mf)
  if(is.null(offset)) offset <- rep(0, NROW(X))
  offset <- as.vector(offset)

  ## call default method
  rval <- xsubset.default(X, Y, weights, offset, na.action = na.action, ...)

  ## add formula/model.frame type information
  rval$call <- call
  rval$formula <- formula
  rval$terms <- mt
  rval$model <- if(model) mf else NULL
  if(!y) rval$y <- NULL
  if(!x) rval$x <- NULL
  if(!is.null(attr(mf, "na.action"))) rval$na.action <- attr(mf, "na.action")

  return(rval)
}

## interface for fitted lm regression
xsubset.lm <- function(object, ..., model = TRUE, y = TRUE, x = FALSE)
{
  ## keep call (of generic)
  call <- match.call()
  call[[1]] <- as.name("xsubset")

  ## extract information from fitted model object
  mt <- terms(object)
  mf <- model.frame(object)
  X <- if(is.matrix(object$x)) object$x else model.matrix(mt, mf)
  Y <- if(is.vector(object$y)) object$y else model.response(mf)
  weights <- weights(object)
  offset <- object$offset

  ## call default method
  rval <- xsubset.default(X, Y, weights, offset, ...)
  
  ## add formula/model.frame type information
  rval$call <- call
  rval$formula <- formula(object)
  rval$terms <- mt
  rval$model <- if(model) mf else NULL
  if(!y) rval$y <- NULL
  if(!x) rval$x <- NULL
  if(!is.null(attr(mf, "na.action"))) rval$na.action <- attr(mf, "na.action")  
  rval$contrasts <- object$contrasts
  
  return(rval)
}

## workhorse method
xsubset.default <- function(object, y, weights = NULL, offset = NULL,
  size = NULL, pradius = NULL, tol = 0,
  criterion = NULL, include = NULL, exclude = NULL,
  na.action = na.omit, ...)
{
  ## keep call (of generic)
  call <- match.call()
  call[[1]] <- as.name("xsubset")

  ## process x, y, offset
  x <- as.matrix(object)
  stopifnot(is.numeric(x), is.numeric(y), NROW(x) == NROW(y))
  if(is.null(offset)) offset <- rep(0, length(y))  
  stopifnot(length(offset) == length(y))
  ay <- cbind(x, y - offset)
  if(any(is.na(ay))) {
    ay <- na.action(ay)
    na.action <- attr(ay, "na.action")
  } else {
    na.action <- NULL
  }
  nobs <- nobs0 <- nrow(ay)
  nvar <- ncol(ay)
  nreg <- nvar - 1

  ## has intercept?
  intercept <- isTRUE(all.equal(as.vector(x[,1]), rep(1, nobs)))

  ## process weights
  if(is.null(weights)) weights <- rep(1, nobs)
  if(!isTRUE(all.equal(as.vector(weights), rep(1, nobs)))) {
    if(any(weights < 0)) {
      warning("negative weights are not allowed, set to zero")
      weights[weights < 0] <- 0
    }
    ay <- sqrt(weights[weights > 0]) * ay[weights > 0, , drop = FALSE]
    nobs <- NROW(ay)
  }

  ## include processing
  if(is.null(include)) include <- as.integer(intercept) else {
    if(is.character(include)) include <- match(include, colnames(x))
    if(is.logical(include)) which(rep(include, length.out = nvar - 1))
    if(any(is.na(include))) {
      warning("non-existing columns selected in 'include'")
      include <- na.omit(include)
    }
    if(length(include) < 1) include <- 0
    if(any(include < 0)) {
      warning("negative indices are not allowed in 'include'")
      include[include >= 0]
    }
    if(any(include >= nvar)) {
      warning("'include' indices can not be larger than number of columns")
      include[include < nvar]
    }
  }
  include <- sort(unique(round(include)))
  if(length(include) > 1) include <- include[include > 0]

  ## exclude processing
  if(is.null(exclude)) exclude <- 0 else {
    if(is.character(exclude)) exclude <- match(exclude, colnames(x))
    if(is.logical(exclude)) which(rep(exclude, length.out = nvar - 1))
    if(any(is.na(exclude))) {
      warning("non-existing columns selected in 'exclude'")
      exclude <- na.omit(exclude)
    }
    if(length(exclude) < 1) exclude <- 0
    if(any(exclude < 0)) {
      warning("negative indices are not allowed in 'exclude'")
      exclude[exclude >= 0]
    }  
    if(any(exclude >= nvar)) {
      warning("'exclude' indices can not be larger than number of columns")
      exclude[exclude < nvar]
    }
  }
  exclude <- sort(unique(round(exclude)))
  if(length(exclude) > 1) exclude <- exclude[exclude > 0]

  ## include/exclude non-overlapping
  if(include[1] > 0 & exclude[1] > 0) {
    if(any(!is.na(inex <- match(include, exclude)))) {
      warning("'include' and 'exclude' must not be overlapping, modified 'exclude'")
      exclude <- exclude[-na.omit(inex)]
    }
  }

  ## re-order columns to incorporate include/exclude
  colnames(ay) <- 1:nvar
  ix <- c(include, exclude)
  ix <- if(any(ix > 0)) (1:(nvar-1))[-ix] else (1:(nvar-1))
  ay <- ay[, c(include[include > 0], ix, nvar), drop = FALSE]
  nvar <- nvar - length(exclude[exclude > 0])

  ## fixed first columns      
  mark <- length(include[include > 0])
  if(mark > 0) {
    null.rss <- sum(weights * (lm.wfit(x[, include, drop = FALSE], y - offset, weights)$residuals)^2)
  } else {
    null.rss <- sum(weights * (y - offset)^2)    
  }

  ## size processing
  size <- if(is.null(size)) (mark + 1):(nvar - 1) else sort(unique(round(size)))
  if(max(size) >= nvar) {
    warning(paste("'size' can not be larger than", nvar - 1))
    size <- size[size <= nvar - 1]
  }
  if(min(size) < mark) {
    warning(paste("'size' must at least be", mark))
    size <- size[size >= mark]
  }
  size <- size[size > mark]
  if(length(size) < 1) size <- (mark + 1):(nvar - 1)
  
  ## tolerance
  .TAU_MAX <- .Machine$double.xmax
  ntol <- rep(.TAU_MAX, length.out = nvar - 1)
  ntol[size] <- rep(tol, length.out = length(size))
  tol <- ntol
  
  ## pradius default
  if(is.null(pradius)) pradius <- pmax(round(NROW(x)/3), 1)

  ## call underlying C code
  C_rval <- .C(name = "xsubset_R",
    ## in
    nobs = as.integer(nobs),
    nvar = as.integer(nvar),
    ay   = as.numeric(ay),
    mark = as.integer(mark),
    prad = as.integer(pradius),
    tau  = as.numeric(tol),
    ## out
    rsel = numeric(nvar - 1),
    isel = integer(nvar * (nvar - 1) / 2),
    nvis = integer(1)
  )

  ## extract selected variables and associated RSS
  vwhich <- lapply(size, function(i) {
    j <- i * (i - 1) / 2
    C_rval$isel[(j + 1 + mark):(j + i)] + 1
  })
  ## combine with included columns
  vwhich <- lapply(vwhich, function(i) sort(c(include[include > 0], as.integer(colnames(ay)[i]))))
  rss <- C_rval$rsel[size]  
  ## include null
  size <- c(mark, size)
  vwhich <- c(structure(list(include[include > 0]), .Names = mark), vwhich)
  rss <- c(null.rss, rss)
  ## names
  names(vwhich) <- names(rss) <- size

  ## compute criterion and best model
  logL <- 0.5 * (sum(log(weights[weights > 0])) - nobs * (log(2 * pi) + 1 - log(nobs) + log(rss)))
  df <- size + 1
  if(is.null(criterion)) {
    crit <- -2 * logL + log(nobs) * df
    critnam <- "BIC"
  } else {
    if(is.numeric(criterion)) {
      criterion <- criterion[1L]
      crit <- -2 * logL + criterion * df
      critnam <- if(isTRUE(all.equal(criterion, 2))) {
        "AIC"
      } else if(isTRUE(all.equal(criterion, log(nobs)))) {
        "BIC"
      } else {
        "modified AIC"
      }      
    } else if(is.function(criterion)) {
      logL <- lapply(1:length(size), function(i) structure(logL[i], df = df[i], class = "logLik"))
      crit <- sapply(logL, criterion)
      critnam <- deparse(substitute(criterion))
    } else {
      stop("invalid 'criterion' specified")
    }
  }
  best <- size[which.min(crit)]
  crit <- matrix(crit, nrow = 1, ncol = length(size))
  colnames(crit) <- size
  rownames(crit) <- critnam

  rval <- list(
    call = call,
    size = size,
    rss = rss,
    which = vwhich,
    include = include,
    exclude = exclude,
    criterion = crit,
    best = best,
    x = x,
    y = y,
    weights = if(isTRUE(all.equal(as.vector(weights), rep(1, nobs0)))) NULL else weights,
    offset = if(isTRUE(all.equal(as.vector(offset), rep(0, nobs0)))) NULL else offset,
    nobs = nobs0,
    nreg = nreg,
    intercept = intercept,
    pradius = pradius,
    tol = tol,
    nvisited = C_rval$nvis,
    na.action = na.action
  )
  class(rval) <- "xsubset"
  return(rval)
}

print.xsubset <- function(x, ...)
{
  cat("\nCall:", deparse(x$call, width.cutoff = floor(getOption("width") * 0.85)), sep = "\n")

  ## format size
  size <- x$size
  size <- if(isTRUE(all.equal(as.vector(size), min(size):max(size)))) paste(min(size), max(size), sep = ":")
    else paste(size, collapse = ", ")
  
  rval <- format(c(x$nobs, x$nreg, x$best), width = max(nchar(size), 3))
  rval <- as.matrix(c(rval[1:2], size, rval[3]))
  colnames(rval) <- ""
  rownames(rval) <- c("Number of observations:", "Number of regressors:",
    "Subset sizes assessed:", paste("Best", rownames(x$criterion) , "subset size:"))
  print(rval, quote = FALSE)
  
  invisible(x)
}

summary.xsubset <- function(object, size = NULL, ...) {

  ## get size and associated which
  if(is.null(size)) size <- object$size
  which <- object$which  

  ## get maximal model matrix
  x <- if(is.null(object$x)) model.matrix(terms(object), model.frame(object)) else object$x

  ## number of observations
  nobs <- if(is.null(object$weights)) object$nobs else sum(object$weights > 0)

  ## collect information
  rss <- deviance(object, size = size)
  crit <- object$criterion[, object$size %in% size, drop = FALSE]
  wbest <- which(size == object$best)
  nwhich <- matrix(FALSE, ncol = length(size), nrow = ncol(x))
  for(i in 1:length(size)) {
    wi <- which[[as.character(size[i])]]
    if(!is.null(wi)) nwhich[wi, i] <- TRUE
  }
  rownames(nwhich) <- colnames(x)
  colnames(nwhich) <- size
  colnames(nwhich)[wbest] <- paste(colnames(nwhich)[wbest], "*", sep = "")
  rownames(nwhich)[object$include] <- paste("+", rownames(nwhich)[object$include], sep = "")
  rownames(nwhich)[object$exclude] <- paste("-", rownames(nwhich)[object$exclude], sep = "")
  
  ## replace some slots with updated information
  object$size <- size
  object$which <- nwhich
  object$rss <- rss
  object$criterion <- crit

  ## delete some slots
  object$x <- object$y <- object$formula <- object$terms <- object$model <-
    object$na.action <- object$contrasts <- object$weights <- object$offset <- NULL
  class(object) <- "summary.xsubset"

  return(object)
}

print.summary.xsubset <- function(x, digits = max(3, getOption("digits") - 3), ...)
{
  cat("\nCall:", deparse(x$call, width.cutoff = floor(getOption("width") * 0.85)), "", sep = "\n")

  cat("Selected variables:\n")
  wi <- x$which
  wi[] <- ifelse(wi, "x", "")
  print(wi, quote = FALSE)

  cat("\nModel fit:\n")
  fit <- rbind(x$criterion, x$rss)
  rownames(fit) <- c(rownames(x$criterion), "RSS")
  colnames(fit) <- colnames(wi)
  print(fit, digits = digits)
    
  invisible(x)
}

plot.xsubset <- function(x, size = NULL, legend = TRUE,
  xlab = "Number of regressors in model", ylab = "",
  main = NULL,
  col = c(1, 4), lty = 1, type = "b", ...)
{
  ## extract main info
  if(is.null(size)) size <- x$size
  rss <- deviance(x, size = size)
  crit <- x$criterion[, x$size %in% size, drop = FALSE]

  col <- rep(col, length.out = 2)
  type <- rep(type, length.out = 2)
  lty <- rep(lty, length.out = 2)
  if(is.null(main)) main <- paste(rownames(x$criterion), "and residual sum of squares")

  plot(size, as.vector(crit),
    ylab = ylab, xlab = xlab, main = main,
    type = type[1], lty = lty[1], col = col[1], ...)
  onew <- getOption("new")
  par(new = TRUE)
  plot(size, rss, type = type[2], axes = FALSE, col = col[2], xlab = "", ylab = "")
  if(legend) legend("topright", c(rownames(x$criterion), "RSS"), lty = lty, col = col, bty = "n")
  axis(4)
  par(new = onew)
  invisible(x)
}

deviance.xsubset <- function(object, size = NULL, ...) {
  rsize <- if(is.null(size)) object$size else size
  size <- object$size
  if(!all(rsize %in% size)) stop("requested 'size' not available")
  rval <- object$rss[which(size %in% rsize)]
  if(length(rval) < 2) rval <- as.vector(rval)
  return(rval)
}

logLik.xsubset <- function(object, size = NULL, ...) {
  size <- if(is.null(size)) object$best else size[1]
  if(is.null(object$weights)) {
    nobs <- object$nobs 
    sw <- 0
  } else {
    weights <- object$weights
    nobs <- sum(weights > 0)
    sw <- sum(log(weights[weights > 0]))
  }
  rss <- deviance(object, size = size)
  structure(0.5 * (sw - nobs * (log(2 * pi) + 1 - log(nobs) + log(rss))),
    df = size + 1, class = "logLik")
}

AIC.xsubset <- function(object, size = NULL, ..., k = 2) {
  if(is.null(size)) size <- object$size
  rval <- sapply(size, function(i) AIC(logLik(object, size = i, ..., k = k)))
  names(rval) <- size
  return(rval)
}

model.frame.xsubset <- function(formula, ...) {
  if(!is.null(formula$model)) return(formula$model)
  if(is.null(formula$formula)) stop("'model.frame' not available")
  NextMethod()
}

model.matrix.xsubset <- function(object, size = NULL, ...) {
  size <- if(is.null(size)) object$best else size[1]
  if(!any(size == object$size)) stop("requested 'size' not available")
  x <- object$x
  if(is.null(object$x)) x <- model.matrix(terms(object), model.frame(object), contrasts = object$contrasts)
  wi <- which(size == object$size)
  wi <- object$which[[wi]]
  if(is.null(wi)) wi <- 0
  x[, wi, drop = FALSE]
}

refit.xsubset <- function(object, size = NULL, ...) {
  size <- if(is.null(size)) object$best else size[1]

  ## extract x/y
  x <- model.matrix(object, size = size)
  if(object$intercept) x <- x[, -1, drop = FALSE]
  y <- if(!is.null(object$y)) object$y else model.response(model.frame(object))
  
  ## set up data.frame and formula
  data <- cbind(data.frame(y = y), as.data.frame(x))
  if(!is.null(object$formula)) names(data)[1] <- as.character(object$formula[[2]])  
  formula <- as.formula(paste(names(data)[1], "~",
    if(ncol(x) < 1) {
      if(object$intercept) "1" else "0"
    } else {
      if(object$intercept) NULL else "0 +"
    }, paste(names(data)[-1], collapse = " + ")))
  
  ## offset and weights
  offset <- object$offset
  weights <- object$weights
  
  lm(formula, data, weights = weights, offset = offset)
}

coef.xsubset <- function(object, size = NULL, ...) {
  coef(refit(object, size), ...)
}

vcov.xsubset <- function(object, size = NULL, ...) {
  vcov(refit(object, size), ...)
}

fitted.xsubset <- function(object, size = NULL, ...) {
  fitted(refit(object, size), ...)
}

residuals.xsubset <- function(object, size = NULL, ...) {
  residuals(refit(object, size), ...)
}

